/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/_admin/connectors/s3/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Register S3
         * @description Register or update S3 connector config (persisted to DB with encryption).
         */
        post: operations["register_s3__admin_connectors_s3_register_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/gcs/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Register Gcs
         * @description Register or update GCS connector config (persisted to DB with encryption).
         */
        post: operations["register_gcs__admin_connectors_gcs_register_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/drive/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Register Drive
         * @description Register or update Drive connector config (persisted to DB with encryption).
         */
        post: operations["register_drive__admin_connectors_drive_register_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Connectors
         * @description List all connector configs (metadata only, no secrets).
         */
        get: operations["list_connectors__admin_connectors__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/{provider}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Connector
         * @description Get connector config metadata (no secrets) for specific tenant+provider.
         */
        get: operations["get_connector__admin_connectors__provider__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/{provider}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable Connector
         * @description Enable connector for tenant.
         */
        post: operations["enable_connector__admin_connectors__provider__enable_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/{provider}/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Disable Connector
         * @description Disable connector for tenant.
         */
        post: operations["disable_connector__admin_connectors__provider__disable_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/{provider}/backfill": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Backfill
         * @description Trigger manual backfill for a connector provider (s3|gcs).
         */
        post: operations["backfill__admin_connectors__provider__backfill_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/drive/cursor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Drive Cursor
         * @description Get current Drive connector cursor status for a tenant.
         */
        get: operations["get_drive_cursor__admin_connectors_drive_cursor_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_webhooks/s3": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Handle S3 Webhook
         * @description Handle S3 event notification via SNS.
         *
         *     SNS sends two message types:
         *     1. SubscriptionConfirmation - one-time setup
         *     2. Notification - actual S3 events
         *
         *     Security:
         *     - Timeout: 5s max
         *     - Size: 1MB max
         *     - Signature verification
         *     - Replay protection
         *
         *     Returns:
         *         200 OK if processed/queued
         *         400 Bad Request if invalid
         *         403 Forbidden if signature invalid
         *         429 Too Many Requests if rate limited
         */
        post: operations["handle_s3_webhook__webhooks_s3_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_webhooks/s3/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Webhook Health
         * @description Health check for webhook endpoint.
         */
        get: operations["webhook_health__webhooks_s3_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_webhooks/gcs/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gcs Webhook Health
         * @description Health check for GCS webhook endpoint (Redis connectivity).
         */
        get: operations["gcs_webhook_health__webhooks_gcs_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_webhooks/gcs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Handle Gcs Pubsub
         * @description Handle Google Cloud Pub/Sub push for GCS notifications.
         *
         *     Expected JSON envelope:
         *     {
         *       "message": {
         *         "messageId": "...",
         *         "data": "base64-encoded",
         *         "attributes": { "bucketId": "...", "objectId": "...", "eventType": "...", "objectGeneration": "..." }
         *       },
         *       "subscription": "projects/.../subscriptions/..."
         *     }
         */
        post: operations["handle_gcs_pubsub__webhooks_gcs_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Health */
        get: operations["health_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/cache/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Connector Cache Health
         * @description Health endpoint for connector cache subscriber.
         *
         *     Security:
         *         - When JWT is enabled, require authenticated token (no specific scope required for health check)
         *         - When JWT is disabled (dev mode), allow access
         *
         *     Returns:
         *         Status dict with subscriber health information
         */
        get: operations["connector_cache_health__admin_connectors_cache_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/rotate_keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Connector Rotate Keys
         * @description Rotate encryption keys for connector configs.
         *
         *     Selects rows where key_version != ACTIVE_VERSION, decrypts with old key,
         *     re-encrypts with active key, and updates key_version.
         *
         *     Security:
         *         - When JWT is enabled, require authenticated token
         *         - When JWT is disabled (dev mode), allow access
         *
         *     Args:
         *         request: Rotation parameters (providers, tenants, batch_size, dry_run)
         *
         *     Returns:
         *         Summary dict with rotation results
         */
        post: operations["connector_rotate_keys__admin_connectors_rotate_keys_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_admin/connectors/purge_deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Purge Deleted Nodes
         * @description Purge soft-deleted nodes past their grace period.
         *
         *     Deletes nodes with 'Deleted' class where deletion_grace_until < NOW().
         *     Deletes chunks first (via parent_id), then parent documents.
         *
         *     Security:
         *         - When JWT is enabled, require authenticated token (admin:refresh scope recommended)
         *         - When JWT is disabled (dev mode), allow access
         *
         *     Args:
         *         request: Purge parameters (tenant_id, batch_size, dry_run)
         *
         *     Returns:
         *         Summary dict with purge results
         */
        post: operations["purge_deleted_nodes__admin_connectors_purge_deleted_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/debug/dbinfo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Debug Dbinfo
         * @description Debug endpoint to inspect DB and tenant context.
         *
         *     Security:
         *         - When JWT is enabled, require an authenticated token with admin privileges (admin:refresh scope).
         *         - When JWT is disabled (dev mode), allow access.
         *
         *     Returns:
         *         {
         *           "database": str,
         *           "tenant_context": Optional[str],
         *           "server_host": Optional[str],
         *           "server_port": Optional[int]
         *         }
         */
        get: operations["debug_dbinfo_debug_dbinfo_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/debug/search_sanity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Debug Search Sanity
         * @description Debug endpoint for retrieval sanity checks.
         *
         *     Returns node counts, embedding coverage, and sample nodes to help
         *     diagnose empty search results or low citation rates.
         *
         *     Security:
         *         - When JWT is enabled, require admin:refresh scope.
         *         - When JWT is disabled (dev mode), allow access.
         *
         *     Returns:
         *         {
         *           "tenant_id": str,
         *           "total_nodes": int,
         *           "nodes_with_embeddings": int,
         *           "nodes_with_text_search": int,
         *           "embedding_coverage_pct": float,
         *           "text_search_coverage_pct": float,
         *           "sample_nodes_with_embedding": List[{id, classes, has_text}],
         *           "sample_nodes_without_embedding": List[{id, classes, has_text}]
         *         }
         */
        get: operations["debug_search_sanity_debug_search_sanity_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/debug/search_explain": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Debug Search Explain
         * @description Debug endpoint for detailed search result triage.
         *
         *     Returns top-k results with similarity scores, snippets, and metadata
         *     to help diagnose retrieval issues and tune thresholds.
         *
         *     Security:
         *         - When JWT is enabled, require admin:refresh scope.
         *         - When JWT is disabled (dev mode), allow access.
         *
         *     Args:
         *         query: Search query text
         *         use_hybrid: Whether to use hybrid BM25+vector search
         *         top_k: Number of results to return (max 20)
         *
         *     Returns:
         *         {
         *           "query": str,
         *           "mode": "vector" | "hybrid",
         *           "result_count": int,
         *           "results": [
         *             {
         *               "node_id": str,
         *               "similarity": float,
         *               "classes": List[str],
         *               "snippet": str (first 300 chars of props.text),
         *               "metadata": dict,
         *               "has_embedding": bool,
         *               "has_text_search": bool
         *             }
         *           ],
         *           "threshold_info": {
         *             "recommended_min": float,
         *             "recommended_max": float,
         *             "top_similarity": float,
         *             "bottom_similarity": float
         *           }
         *         }
         */
        post: operations["debug_search_explain_debug_search_explain_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/debug/embed_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Debug Embed Info
         * @description Debug endpoint to inspect embedding configuration and stored vectors.
         *
         *     Security:
         *         - When JWT is enabled, require admin:refresh scope.
         *         - When JWT is disabled (dev mode), allow access.
         *
         *     Returns:
         *         {
         *           "embedding_backend": str,
         *           "embedding_model": str,
         *           "counts": {"total_nodes": int, "with_embedding": int, "without_embedding": int},
         *           "vector_dimension": {"db_type": str | None, "db_dim": int | None, "sampled_dims": List[int]},
         *           "sample": {"n": int, "norm_min": float, "norm_max": float, "norm_mean": float, "example_ids": List[str]}
         *         }
         */
        get: operations["debug_embed_info_debug_embed_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/debug/intent": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Debug Intent
         * @description Debug endpoint to test intent detection without running full /ask.
         *
         *     Example: GET /debug/intent?q=What%20ML%20frameworks%20does%20the%20position%20require
         *
         *     Returns: {
         *         "query": str,
         *         "normalized": str,
         *         "intent_type": str | None,
         *         "params": dict | None
         *     }
         */
        get: operations["debug_intent_debug_intent_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Metrics
         * @description Get metrics in JSON format.
         */
        get: operations["get_metrics_metrics_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/prometheus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Prometheus Metrics
         * @description Get metrics in Prometheus exposition format using prometheus_client.
         *
         *     Provides detailed metrics for observability:
         *     - Request counters by score_type and rejection status
         *     - Gating score histograms
         *     - Citation quality metrics
         *     - Latency histograms
         *     - Embedding health gauges
         *
         *     Format: https://prometheus.io/docs/instrumenting/exposition_formats/
         */
        get: operations["prometheus_metrics_prometheus_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Nodes
         * @description List nodes with optional class filtering.
         *
         *     Security:
         *         When JWT_ENABLED=true, tenant_id derives from JWT claims.
         */
        get: operations["list_nodes_nodes_get"];
        put?: never;
        /**
         * Create Node
         * @description Create a new node with validated input.
         *
         *     Security:
         *         When JWT_ENABLED=true, tenant_id is derived from JWT claims (secure).
         *         When JWT_ENABLED=false (dev mode), tenant_id can be provided in request body.
         */
        post: operations["create_node_nodes_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{node_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Node
         * @description Get a node by ID.
         *
         *     Security:
         *         When JWT_ENABLED=true, tenant_id is derived from JWT claims (secure).
         *         Query param tenant_id is IGNORED in production to prevent RLS bypass.
         */
        get: operations["get_node_nodes__node_id__get"];
        /**
         * Update Node
         * @description Update mutable fields of a node (classes, props, payload_ref, metadata, refresh_policy, triggers).
         */
        put: operations["update_node_nodes__node_id__put"];
        post?: never;
        /**
         * Delete Node
         * @description Delete a node. By default performs a soft-delete (adds 'Deleted' class). Set hard=true for permanent delete.
         */
        delete: operations["delete_node_nodes__node_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/demo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Demo Page
         * @description Minimal self-serve console for demo and testing.
         */
        get: operations["demo_page_demo_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{node_id}/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh Node
         * @description Manually refresh a single node's embedding and write history/events.
         *
         *     Computes drift vs prior embedding; emits a refreshed event if drift exceeds threshold.
         *
         *     Security:
         *         Requires JWT authentication when JWT_ENABLED=true.
         *         Tenant ID derived from JWT claims to prevent cross-tenant refresh.
         */
        post: operations["refresh_node_nodes__node_id__refresh_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search Nodes
         * @description Semantic search across knowledge graph nodes using pgvector.
         *
         *     Embeds the query text and returns top-K similar nodes with similarity scores.
         *
         *     Supports two search modes:
         *     1. Vector-only (default): Pure semantic similarity using embeddings
         *     2. Hybrid (use_hybrid=True): BM25 + vector fusion with optional cross-encoder reranking
         *
         *     Weighted scoring (when use_weighted_score=True):
         *     - Applies age decay: fresher nodes score higher
         *     - Applies drift penalty: lower drift scores higher
         *     - Formula: similarity * exp(-decay_lambda * age_days) * (1 - drift_beta * drift_score)
         *
         *     Security:
         *         When JWT_ENABLED=true, tenant_id is derived from JWT claims (secure).
         *         Query param tenant_id is IGNORED in production to prevent RLS bypass.
         */
        post: operations["search_nodes_search_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ask": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ask Question
         * @description LLM-powered Q&A with grounded citations from knowledge graph.
         *
         *     Uses structured KG for retrieval, LLM for natural language answer generation.
         *     All facts are cited with node IDs and lineage chains (Zhu et al., 2023 design).
         *
         *     Example:
         *         POST /ask {"question": "What are the best ML engineering candidates?"}
         *
         *     Returns:
         *         {
         *             "answer": "Based on recent resumes:\n1. Jane Doe (5yrs PyTorch) [0]\n2. ...",
         *             "citations": [
         *                 {
         *                     "node_id": "resume_123",
         *                     "classes": ["Resume"],
         *                     "drift_score": 0.08,
         *                     "age_days": 1.2,
         *                     "lineage": [{"ancestor": "linkedin_profile_456", "depth": 1}]
         *                 }
         *             ],
         *             "confidence": 0.92,
         *             "metadata": {"searched_nodes": 5, "cited_nodes": 3}
         *         }
         */
        post: operations["ask_question_ask_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ask/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ask Stream
         * @description Server-Sent Events streaming for LLM Q&A with citations.
         *
         *     Streams tokens as they are generated and emits a final JSON payload with
         *     citations, confidence, and metadata.
         */
        post: operations["ask_stream_ask_stream_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/edges": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Edge
         * @description Create a relationship between two nodes with validated input.
         *
         *     Security:
         *         When JWT_ENABLED=true, tenant_id is derived from JWT claims (secure).
         *         When JWT_ENABLED=false (dev mode), tenant_id can be provided in request body.
         */
        post: operations["create_edge_edges_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/triggers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Trigger Patterns
         * @description List all registered trigger patterns.
         *
         *     Security:
         *         Returns all patterns (no tenant filtering for system-level triggers).
         *         Rate limited for read protection.
         */
        get: operations["list_trigger_patterns_triggers_get"];
        put?: never;
        /**
         * Register Trigger Pattern
         * @description Register a semantic trigger pattern.
         *
         *     Expects: {"name": "pattern_name", "example_text": "...", "description": "..."}
         *
         *     Security:
         *         Requires JWT authentication when JWT_ENABLED=true.
         *         Triggers are global resources (not tenant-scoped).
         */
        post: operations["register_trigger_pattern_triggers_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/triggers/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Trigger Pattern
         * @description Delete a trigger pattern by name.
         *
         *     Security:
         *         Requires JWT authentication when JWT_ENABLED=true.
         */
        delete: operations["delete_trigger_pattern_triggers__name__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Events
         * @description List events with optional filtering by node_id, event_type, and tenant.
         *
         *     Security:
         *         When JWT_ENABLED=true, tenant_id is derived from JWT claims (secure).
         *         Query param tenant_id is IGNORED in production to prevent RLS bypass.
         */
        get: operations["list_events_events_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/lineage/{node_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Lineage
         * @description Traverse DERIVED_FROM edges to retrieve provenance lineage.
         *
         *     Returns recursive ancestor chain with depth and edge metadata.
         *
         *     Security:
         *         When JWT_ENABLED=true, tenant_id is derived from JWT claims (secure).
         *         Query param tenant_id is IGNORED in production to prevent RLS bypass.
         */
        get: operations["get_lineage_lineage__node_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/migrate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Admin Migrate
         * @description Run idempotent DB bootstrap/migrations and ensure vector index.
         *
         *     Security:
         *         Requires 'admin:refresh' scope when JWT is enabled.
         */
        post: operations["admin_migrate_admin_migrate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/db_status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Admin Db Status
         * @description Report DB schema status: tables, columns, indexes, extensions, and RLS policies.
         *
         *     Security:
         *         Requires 'admin:refresh' scope when JWT is enabled.
         */
        get: operations["admin_db_status_admin_db_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Admin Refresh
         * @description Trigger on-demand refresh cycle.
         *
         *     Requires 'admin:refresh' scope when JWT authentication is enabled.
         *
         *     Args:
         *         node_ids: Optional list of specific node IDs to refresh. If not provided, refreshes all due nodes.
         *
         *     Returns:
         *         Summary of refresh operation
         */
        post: operations["admin_refresh_admin_refresh_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/anomalies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Anomalies
         * @description Detect operational anomalies in the knowledge graph.
         *
         *     Supported anomaly types:
         *     - drift_spike: Nodes with drift > 2x mean for 3+ consecutive refreshes
         *     - trigger_storm: >50 trigger_fired events in 1 hour (runaway triggers)
         *     - scheduler_lag: Nodes overdue for refresh (>2x expected interval)
         *
         *     Args:
         *         types: Comma-separated list of anomaly types to check (default: all)
         *         lookback_hours: Hours to look back for drift/trigger analysis (default: 24)
         *         drift_spike_threshold: Drift multiplier threshold (default: 2.0 = 2x mean)
         *         trigger_storm_threshold: Min trigger events to flag as storm (default: 50)
         *         scheduler_lag_multiplier: Lag multiplier for overdue nodes (default: 2.0 = 2x late)
         *         tenant_id: Optional tenant ID for multi-tenancy filtering
         *
         *     Returns:
         *         Dictionary with anomaly type as key, list of detected anomalies as value
         */
        get: operations["get_anomalies_admin_anomalies_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{node_id}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Node Versions
         * @description Get embedding version history for a node.
         *
         *     Returns the embedding refresh history including drift scores and timestamps.
         *     Useful for debugging drift trends and understanding content evolution.
         *
         *     Security:
         *         When JWT_ENABLED=true, tenant_id is derived from JWT claims for RLS enforcement.
         *
         *     Args:
         *         node_id: Node ID to query
         *         limit: Maximum number of versions to return (default: 10, max: 100)
         *
         *     Returns:
         *         List of version records with version_index, drift_score, created_at, embedding_ref
         */
        get: operations["get_node_versions_nodes__node_id__versions_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AskRequest
         * @description LLM-powered Q&A request with grounded citations.
         */
        AskRequest: {
            /**
             * Question
             * @description Question to answer using KG context
             */
            question: string;
            /**
             * Max Results
             * @description Max context nodes to retrieve
             * @default 5
             */
            max_results: number | null;
            /**
             * Tenant Id
             * @description Tenant ID for multi-tenancy
             */
            tenant_id?: string | null;
            /**
             * Use Weighted Score
             * @description Use recency/drift weighting for context (default: True)
             * @default true
             */
            use_weighted_score: boolean;
        };
        /** BackfillRequest */
        BackfillRequest: {
            /** Tenant Id */
            tenant_id?: string | null;
            /**
             * Limit
             * @default 200
             */
            limit: number;
        };
        /** Body_debug_search_explain_debug_search_explain_post */
        Body_debug_search_explain_debug_search_explain_post: {
            /** Query */
            query: string;
            /**
             * Use Hybrid
             * @default false
             */
            use_hybrid: boolean;
            /**
             * Top K
             * @default 5
             */
            top_k: number;
        };
        /**
         * DriveConnectorConfig
         * @description Configuration for Google Drive connector.
         */
        DriveConnectorConfig: {
            /** Credentials */
            credentials: string;
            /** Subject Email */
            subject_email?: string | null;
            /** Project */
            project?: string | null;
            /** Shared Drives */
            shared_drives?: string[];
            /** Root Folders */
            root_folders?: string[];
            /** Include Folders */
            include_folders?: string[];
            /** Exclude Folders */
            exclude_folders?: string[];
            /** Include Mime Types */
            include_mime_types?: string[];
            /** Export Formats */
            export_formats?: {
                [key: string]: string;
            };
            /**
             * Poll Interval Seconds
             * @default 300
             */
            poll_interval_seconds: number;
            /**
             * Page Size
             * @default 100
             */
            page_size: number;
            /**
             * Use Changes Feed
             * @default true
             */
            use_changes_feed: boolean;
            /**
             * Max File Size Bytes
             * @default 104857600
             */
            max_file_size_bytes: number;
            /** Webhook Secret */
            webhook_secret?: string | null;
            /**
             * Enabled
             * @default true
             */
            enabled: boolean;
        };
        /**
         * EdgeCreate
         * @description Validated edge creation request.
         *
         *     Security note:
         *         When JWT_ENABLED=true, tenant_id from JWT claims overrides this field.
         *         The tenant_id field is only used in dev mode (JWT_ENABLED=false).
         */
        EdgeCreate: {
            /**
             * Src
             * @description Source node ID
             */
            src: string;
            /**
             * Dst
             * @description Target node ID
             */
            dst: string;
            /**
             * Rel
             * @description Relationship type (e.g., 'WORKS_WITH', 'REPORTS_TO')
             */
            rel: string;
            /**
             * Props
             * @description Edge properties (arbitrary JSON)
             */
            props?: {
                [key: string]: unknown;
            };
            /**
             * Tenant Id
             * @description Tenant ID (dev mode only, overridden by JWT in production)
             */
            tenant_id?: string | null;
        };
        /** EnableDisableRequest */
        EnableDisableRequest: {
            /** Tenant Id */
            tenant_id: string;
        };
        /**
         * GCSConnectorConfig
         * @description Configuration for Google Cloud Storage connector.
         */
        GCSConnectorConfig: {
            /** Bucket */
            bucket: string;
            /**
             * Prefix
             * @default
             */
            prefix: string;
            /** Project */
            project?: string | null;
            /** Credentials Path */
            credentials_path?: string | null;
            /**
             * Poll Interval Seconds
             * @default 900
             */
            poll_interval_seconds: number;
            /**
             * Enabled
             * @default true
             */
            enabled: boolean;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /** HealthCheckResponse */
        HealthCheckResponse: {
            /** Status */
            status: string;
            /** Timestamp */
            timestamp: string;
            /** Version */
            version: string;
            /** Uptime Seconds */
            uptime_seconds: number;
            /** Components */
            components: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
            /** Llm Backend */
            llm_backend?: string | null;
            /** Llm Model */
            llm_model?: string | null;
        };
        /**
         * KGSearchRequest
         * @description Knowledge Graph semantic search request.
         */
        KGSearchRequest: {
            /**
             * Query
             * @description Semantic search query text
             */
            query: string;
            /**
             * Top K
             * @description Number of results to return
             * @default 10
             */
            top_k: number;
            /**
             * Metadata Filters
             * @description Simple equality filters (key-value pairs)
             */
            metadata_filters?: {
                [key: string]: unknown;
            } | null;
            /**
             * Compound Filter
             * @description JSONB containment filter for nested/typed queries
             */
            compound_filter?: {
                [key: string]: unknown;
            } | null;
            /**
             * Tenant Id
             * @description Tenant ID for multi-tenancy
             */
            tenant_id?: string | null;
            /**
             * Use Weighted Score
             * @description Apply recency/drift weighting (default: False)
             * @default false
             */
            use_weighted_score: boolean;
            /**
             * Use Hybrid
             * @description Use hybrid BM25+vector search with score fusion (default: False)
             * @default false
             */
            use_hybrid: boolean;
            /**
             * Use Reranker
             * @description Apply cross-encoder reranking to hybrid results (default: True)
             * @default true
             */
            use_reranker: boolean;
            /**
             * Decay Lambda
             * @description Age decay rate (default: 0.01 = ~1% per day)
             * @default 0.01
             */
            decay_lambda: number;
            /**
             * Drift Beta
             * @description Drift penalty weight (default: 0.1)
             * @default 0.1
             */
            drift_beta: number;
        };
        /** MetricsResponse */
        MetricsResponse: {
            /** Counters */
            counters: {
                [key: string]: number;
            };
            /** Gauges */
            gauges: {
                [key: string]: number;
            };
            /** Histograms */
            histograms: {
                [key: string]: {
                    [key: string]: number;
                };
            };
            /** Timestamp */
            timestamp: string;
        };
        /**
         * NodeCreate
         * @description Validated node creation request.
         *
         *     Security note:
         *         When JWT_ENABLED=true, tenant_id from JWT claims overrides this field.
         *         The tenant_id field is only used in dev mode (JWT_ENABLED=false).
         */
        NodeCreate: {
            /**
             * Classes
             * @description Node class labels (e.g., ['Person', 'Employee'])
             */
            classes: string[];
            /**
             * Props
             * @description Node properties (arbitrary JSON)
             */
            props: {
                [key: string]: unknown;
            };
            /**
             * Payload Ref
             * @description External payload reference (URL, S3 key, etc.)
             */
            payload_ref?: string | null;
            /**
             * Metadata
             * @description Additional metadata
             */
            metadata?: {
                [key: string]: unknown;
            };
            /**
             * Refresh Policy
             * @description Auto-refresh policy configuration
             */
            refresh_policy?: {
                [key: string]: unknown;
            };
            /**
             * Triggers
             * @description Trigger IDs to activate on embedding updates
             */
            triggers?: string[];
            /**
             * Tenant Id
             * @description Tenant ID (dev mode only, overridden by JWT in production)
             */
            tenant_id?: string | null;
        };
        /**
         * NodeUpdate
         * @description Partial update model for nodes.
         */
        NodeUpdate: {
            /** Classes */
            classes?: string[] | null;
            /** Props */
            props?: {
                [key: string]: unknown;
            } | null;
            /** Payload Ref */
            payload_ref?: string | null;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Refresh Policy */
            refresh_policy?: {
                [key: string]: unknown;
            } | null;
            /** Triggers */
            triggers?: {
                [key: string]: unknown;
            }[] | null;
        };
        /**
         * PurgeDeletedRequest
         * @description Request model for soft-delete purger endpoint.
         */
        PurgeDeletedRequest: {
            /** Tenant Id */
            tenant_id?: string | null;
            /**
             * Batch Size
             * @default 500
             */
            batch_size: number;
            /**
             * Dry Run
             * @default false
             */
            dry_run: boolean;
        };
        /** RegisterDriveRequest */
        RegisterDriveRequest: {
            /** Tenant Id */
            tenant_id?: string | null;
            config: components["schemas"]["DriveConnectorConfig"];
        };
        /** RegisterGCSRequest */
        RegisterGCSRequest: {
            /** Tenant Id */
            tenant_id?: string | null;
            config: components["schemas"]["GCSConnectorConfig"];
        };
        /** RegisterS3Request */
        RegisterS3Request: {
            /** Tenant Id */
            tenant_id?: string | null;
            config: components["schemas"]["S3ConnectorConfig"];
        };
        /**
         * RotateKeysRequest
         * @description Request model for connector key rotation endpoint.
         */
        RotateKeysRequest: {
            /** Providers */
            providers?: string[] | null;
            /** Tenants */
            tenants?: string[] | null;
            /**
             * Batch Size
             * @default 100
             */
            batch_size: number;
            /**
             * Dry Run
             * @default false
             */
            dry_run: boolean;
        };
        /**
         * S3ConnectorConfig
         * @description Configuration for S3 connector.
         */
        S3ConnectorConfig: {
            /** Bucket */
            bucket: string;
            /**
             * Prefix
             * @default
             */
            prefix: string;
            /**
             * Region
             * @default us-east-1
             */
            region: string;
            /** Access Key Id */
            access_key_id: string;
            /** Secret Access Key */
            secret_access_key: string;
            /**
             * Poll Interval Seconds
             * @default 900
             */
            poll_interval_seconds: number;
            /**
             * Enabled
             * @default true
             */
            enabled: boolean;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    register_s3__admin_connectors_s3_register_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisterS3Request"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    register_gcs__admin_connectors_gcs_register_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisterGCSRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    register_drive__admin_connectors_drive_register_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisterDriveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_connectors__admin_connectors__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_connector__admin_connectors__provider__get: {
        parameters: {
            query: {
                tenant_id: string;
            };
            header?: never;
            path: {
                provider: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    enable_connector__admin_connectors__provider__enable_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                provider: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EnableDisableRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    disable_connector__admin_connectors__provider__disable_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                provider: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EnableDisableRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    backfill__admin_connectors__provider__backfill_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                provider: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BackfillRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_drive_cursor__admin_connectors_drive_cursor_get: {
        parameters: {
            query: {
                tenant_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    handle_s3_webhook__webhooks_s3_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    webhook_health__webhooks_s3_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    gcs_webhook_health__webhooks_gcs_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    handle_gcs_pubsub__webhooks_gcs_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    health_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthCheckResponse"];
                };
            };
        };
    };
    connector_cache_health__admin_connectors_cache_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    connector_rotate_keys__admin_connectors_rotate_keys_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RotateKeysRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    purge_deleted_nodes__admin_connectors_purge_deleted_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PurgeDeletedRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    debug_dbinfo_debug_dbinfo_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    debug_search_sanity_debug_search_sanity_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    debug_search_explain_debug_search_explain_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Body_debug_search_explain_debug_search_explain_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    debug_embed_info_debug_embed_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    debug_intent_debug_intent_get: {
        parameters: {
            query: {
                q: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_metrics_metrics_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetricsResponse"];
                };
            };
        };
    };
    prometheus_metrics_prometheus_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    list_nodes_nodes_get: {
        parameters: {
            query?: {
                classes?: string | null;
                limit?: number;
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_node_nodes_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NodeCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_node_nodes__node_id__get: {
        parameters: {
            query?: {
                tenant_id?: string | null;
            };
            header?: never;
            path: {
                node_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_node_nodes__node_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                node_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NodeUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_node_nodes__node_id__delete: {
        parameters: {
            query?: {
                hard?: boolean;
            };
            header?: never;
            path: {
                node_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    demo_page_demo_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/html": string;
                };
            };
        };
    };
    refresh_node_nodes__node_id__refresh_post: {
        parameters: {
            query?: {
                tenant_id?: string | null;
            };
            header?: never;
            path: {
                node_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    search_nodes_search_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KGSearchRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    ask_question_ask_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AskRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    ask_stream_ask_stream_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AskRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_edge_edges_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EdgeCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_trigger_patterns_triggers_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    register_trigger_pattern_triggers_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_trigger_pattern_triggers__name__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_events_events_get: {
        parameters: {
            query?: {
                node_id?: string | null;
                event_type?: string | null;
                tenant_id?: string | null;
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_lineage_lineage__node_id__get: {
        parameters: {
            query?: {
                max_depth?: number;
                tenant_id?: string | null;
            };
            header?: never;
            path: {
                node_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    admin_migrate_admin_migrate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    admin_db_status_admin_db_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    admin_refresh_admin_refresh_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": unknown | null;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_anomalies_admin_anomalies_get: {
        parameters: {
            query?: {
                types?: string | null;
                lookback_hours?: number;
                drift_spike_threshold?: number;
                trigger_storm_threshold?: number;
                scheduler_lag_multiplier?: number;
                tenant_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_node_versions_nodes__node_id__versions_get: {
        parameters: {
            query?: {
                limit?: number;
            };
            header?: never;
            path: {
                node_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
